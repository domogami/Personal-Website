"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.withPrefix = withPrefix;
exports.navigateTo = exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactRouterDom = require("react-router-dom");

var _reactLifecyclesCompat = require("react-lifecycles-compat");

var _history = require("history");

var _jsxFileName = "/Users/mike/dev/gatsby-v2/packages/gatsby-link/src/index.js";
let pathPrefix = `/`;

if (typeof __PREFIX_PATHS__ !== `undefined` && __PREFIX_PATHS__) {
  pathPrefix = __PATH_PREFIX__;
}

function withPrefix(path) {
  return normalizePath(pathPrefix + path);
}

function normalizePath(path) {
  return path.replace(/^\/\//g, `/`);
}

const NavLinkPropTypes = {
  activeClassName: _propTypes.default.string,
  activeStyle: _propTypes.default.object,
  exact: _propTypes.default.bool,
  strict: _propTypes.default.bool,
  isActive: _propTypes.default.func,
  location: _propTypes.default.object // Set up IntersectionObserver

};

const handleIntersection = (el, cb) => {
  const io = new window.IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (el === entry.target) {
        // Check if element is within viewport, remove listener, destroy observer, and run link callback.
        // MSEdge doesn't currently support isIntersecting, so also test for  an intersectionRatio > 0
        if (entry.isIntersecting || entry.intersectionRatio > 0) {
          io.unobserve(el);
          io.disconnect();
          cb();
        }
      }
    });
  }); // Add element to the observer

  io.observe(el);
};

class GatsbyLink extends _react.default.Component {
  constructor(props, context) {
    super(); // Default to no support for IntersectionObserver

    let IOSupported = false;

    if (typeof window !== `undefined` && window.IntersectionObserver) {
      IOSupported = true;
    }

    const {
      location
    } = context.router.history;
    const to = (0, _history.createLocation)(props.to, null, null, location);
    this.state = {
      path: (0, _history.createPath)(to),
      to,
      IOSupported,
      location
    };
    this.handleRef = this.handleRef.bind(this);
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.to === nextProps.to) return null;
    const to = (0, _history.createLocation)(nextProps.to, null, null, prevState.location);
    const path = (0, _history.createPath)(to);
    return {
      path,
      to
    };
  }

  componentDidUpdate(prevProps, prevState) {
    // Preserve non IO functionality if no support
    if (this.props.to !== prevProps.to && !this.state.IOSupported) {
      ___loader.enqueue(this.state.path);
    }
  }

  componentDidMount() {
    // Preserve non IO functionality if no support
    if (!this.state.IOSupported) {
      ___loader.enqueue(this.state.to.pathname);
    }
  }

  handleRef(ref) {
    this.props.innerRef && this.props.innerRef(ref);

    if (this.state.IOSupported && ref) {
      // If IO supported and element reference found, setup Observer functionality
      handleIntersection(ref, () => {
        ___loader.enqueue(this.state.to.pathname);
      });
    }
  }

  render() {
    const _this$props = this.props,
          {
      onClick,
      onMouseEnter
    } = _this$props,
          rest = (0, _objectWithoutProperties2.default)(_this$props, ["onClick", "onMouseEnter"]);
    let El;

    if (Object.keys(NavLinkPropTypes).some(propName => this.props[propName])) {
      El = _reactRouterDom.NavLink;
    } else {
      El = _reactRouterDom.Link;
    }

    return _react.default.createElement(El, (0, _extends2.default)({
      onMouseEnter: e => {
        // eslint-disable-line
        onMouseEnter && onMouseEnter(e);

        ___loader.hovering(this.state.path);
      },
      onClick: e => {
        // eslint-disable-line
        onClick && onClick(e);

        if (e.button === 0 && // ignore right clicks
        !this.props.target && // let browser handle "target=_blank"
        !e.defaultPrevented && // onClick prevented default
        !e.metaKey && // ignore clicks with modifier keys...
        !e.altKey && !e.ctrlKey && !e.shiftKey) {
          // Is this link pointing to a hash on the same page? If so,
          // just scroll there.
          let pathname = this.state.path;

          if (pathname.split(`#`).length > 1) {
            pathname = pathname.split(`#`).slice(0, -1).join(``);
          }

          if (pathname === window.location.pathname) {
            const hashFragment = this.state.path.split(`#`).slice(1).join(`#`);
            const element = document.getElementById(hashFragment);

            if (element !== null) {
              element.scrollIntoView();
              return true;
            } else {
              // This is just a normal link to the current page so let's emulate default
              // browser behavior by scrolling now to the top of the page.
              window.scrollTo(0, 0);
              return true;
            }
          } // In production, make sure the necessary scripts are
          // loaded before continuing.


          if (process.env.NODE_ENV === `production`) {
            e.preventDefault();

            window.___navigateTo(this.state.to);
          }
        }

        return true;
      }
    }, rest, {
      to: this.state.to,
      innerRef: this.handleRef,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 112
      },
      __self: this
    }));
  }

}

GatsbyLink.propTypes = (0, _objectSpread2.default)({}, NavLinkPropTypes, {
  innerRef: _propTypes.default.func,
  onClick: _propTypes.default.func,
  to: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.object]).isRequired
});
GatsbyLink.contextTypes = {
  router: _propTypes.default.object
};

var _default = (0, _reactLifecyclesCompat.polyfill)(GatsbyLink);

exports.default = _default;

const navigateTo = to => {
  window.___navigateTo(to);
};

exports.navigateTo = navigateTo;